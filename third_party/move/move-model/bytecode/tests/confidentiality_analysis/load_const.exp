============ initial translation from Move ================

[variant baseline]
fun LoadConst::load_const_while_pc_P($t0|_: u64): u64 {
     var $t1: u64
  0: $t1 := 0
  1: return $t1
}


[variant baseline]
fun LoadConst::load_const_while_pc_S_incorrect($t0|x: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: bool
     var $t4: u64
     var $t5: u64
  0: $t1 := move($t0)
  1: $t2 := 0
  2: $t3 := >($t1, $t2)
  3: if ($t3) goto 4 else goto 7
  4: label L1
  5: $t4 := 0
  6: return $t4
  7: label L0
  8: $t5 := 0
  9: return $t5
}

============ after pipeline `confidentiality_analysis` ================

[variant baseline]
fun LoadConst::load_const_while_pc_P($t0|_: u64): u64 {
     var $t1: u64
  0: $t1 := 0
  1: return $t1
}


[variant baseline]
fun LoadConst::load_const_while_pc_S_incorrect($t0|x: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: bool
     var $t4: u64
     var $t5: u64
  0: $t1 := move($t0)
  1: $t2 := 0
  2: $t3 := >($t1, $t2)
  3: if ($t3) goto 4 else goto 7
  4: label L1
  5: $t4 := 0
  6: return $t4
  7: label L0
  8: $t5 := 0
  9: return $t5
}

============ Diagnostics ================
warning: Implicit data leak via return - off: 6
   ┌─ tests/confidentiality_analysis/load_const.move:3:5
   │
 3 │ ╭     fun load_const_while_pc_S_incorrect(x: u64): u64 {
 4 │ │         if (x > 0) {
 5 │ │             // pc raised, v is S
 6 │ │             let v = 0;
   · │
 9 │ │         0
10 │ │     }
   │ ╰─────^

warning: Implicit data leak via return - off: 9
   ┌─ tests/confidentiality_analysis/load_const.move:3:5
   │
 3 │ ╭     fun load_const_while_pc_S_incorrect(x: u64): u64 {
 4 │ │         if (x > 0) {
 5 │ │             // pc raised, v is S
 6 │ │             let v = 0;
   · │
 9 │ │         0
10 │ │     }
   │ ╰─────^
